<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –º–µ—Ç–∞–ª–ª–æ–ø—Ä–æ–∫–∞—Ç–∞</title>
<meta name="description" content="–û–Ω–ª–∞–π–Ω –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –≤–µ—Å–∞ –º–µ—Ç–∞–ª–ª–æ–ø—Ä–æ–∫–∞—Ç–∞. –¢—Ä—É–±–∞, –∞—Ä–º–∞—Ç—É—Ä–∞, –ª–∏—Å—Ç, —É–≥–æ–ª–æ–∫, —à–≤–µ–ª–ª–µ—Ä, –¥–≤—É—Ç–∞–≤—Ä. –ì–û–°–¢, ASME, EN.">
<style>*{margin:0;padding:0;box-sizing:border-box}body{background:#0b1a0f;overflow-x:hidden}</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useMemo, useCallback, useEffect, useRef } = React;

const METALS = {
  /* ‚îÄ‚îÄ –£–≥–ª–µ—Ä–æ–¥–∏—Å—Ç–∞—è —Å—Ç–∞–ª—å ‚îÄ‚îÄ */
  steel: { name: "–°—Ç–∞–ª—å —É–≥–ª–µ—Ä–æ–¥–∏—Å—Ç–∞—è", density: 7850, group: "–°—Ç–∞–ª—å", search: "—Å—Ç3 —Å—Ç20 09–≥2—Å a106 a333 a53 carbon cs" },
  /* ‚îÄ‚îÄ –ù–µ—Ä–∂–∞–≤–µ—é—â–∞—è ‚Äî –∞—É—Å—Ç–µ–Ω–∏—Ç–Ω–∞—è ‚îÄ‚îÄ */
  ss304: { name: "304 / 304L", density: 7930, group: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", search: "08—Ö18–Ω10 aisi304 1.4301 1.4307 tp304 a312 a240 s30400 s30403" },
  ss321: { name: "321 / 321H", density: 7920, group: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", search: "12—Ö18–Ω10—Ç aisi321 1.4541 tp321 s32100" },
  ss316: { name: "316 / 316L", density: 7980, group: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", search: "08—Ö17–Ω13–º2 10—Ö17–Ω13–º2—Ç aisi316 1.4401 1.4404 tp316 s31600 s31603" },
  ss310: { name: "310 / 310S", density: 7980, group: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", search: "10—Ö23–Ω18 aisi310 1.4845 tp310 s31000 s31008" },
  ss347: { name: "347 / 347H", density: 7960, group: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", search: "08—Ö18–Ω12–± aisi347 1.4550 tp347 s34700" },
  ss904: { name: "904L", density: 7990, group: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", search: "06—Ö–Ω28–º–¥—Ç 1.4539 n08904 s08904" },
  /* ‚îÄ‚îÄ –ù–µ—Ä–∂–∞–≤–µ—é—â–∞—è ‚Äî –¥—É–ø–ª–µ–∫—Å ‚îÄ‚îÄ */
  dup2205: { name: "–î—É–ø–ª–µ–∫—Å 2205", density: 7800, group: "–î—É–ø–ª–µ–∫—Å", search: "s32205 s31803 1.4462 saf2205 duplex" },
  dup2507: { name: "–°—É–ø–µ—Ä–¥—É–ø–ª–µ–∫—Å 2507", density: 7800, group: "–î—É–ø–ª–µ–∫—Å", search: "s32750 1.4410 saf2507 superduplex" },
  /* ‚îÄ‚îÄ –ù–µ—Ä–∂–∞–≤–µ—é—â–∞—è ‚Äî —Ñ–µ—Ä—Ä–∏—Ç–Ω–∞—è/–º–∞—Ä—Ç–µ–Ω—Å–∏—Ç–Ω–∞—è ‚îÄ‚îÄ */
  ss430: { name: "430 (—Ñ–µ—Ä—Ä–∏—Ç–Ω–∞—è)", density: 7700, group: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", search: "12—Ö17 aisi430 1.4016 s43000 ferrit" },
  ss420: { name: "420 (–º–∞—Ä—Ç–µ–Ω—Å–∏—Ç–Ω–∞—è)", density: 7750, group: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", search: "20—Ö13 aisi420 1.4021 s42000 martensit" },
  /* ‚îÄ‚îÄ –ù–∏–∫–µ–ª–µ–≤—ã–µ —Å–ø–ª–∞–≤—ã ‚îÄ‚îÄ */
  nickel200: { name: "Nickel 200", density: 8890, group: "–ù–∏–∫–µ–ª—å", search: "n02200 –Ω–ø2 2.4060 –Ω–∏–∫–µ–ª—å —á–∏—Å—Ç—ã–π" },
  monel400: { name: "Monel 400", density: 8800, group: "–ù–∏–∫–µ–ª—å", search: "n04400 –º–æ–Ω–µ–ª—å –Ω–º–∂–º—Ü 2.4360" },
  inconel600: { name: "Inconel 600", density: 8470, group: "–ù–∏–∫–µ–ª—å", search: "n06600 —Ö–Ω78—Ç –∏–Ω–∫–æ–Ω–µ–ª—å 2.4816" },
  inconel625: { name: "Inconel 625", density: 8440, group: "–ù–∏–∫–µ–ª—å", search: "n06625 —Ö–Ω75–º–±—Ç—é –∏–Ω–∫–æ–Ω–µ–ª—å 2.4856" },
  inconel718: { name: "Inconel 718", density: 8190, group: "–ù–∏–∫–µ–ª—å", search: "n07718 —Ö–Ω45–º–≤—Ç—é–±—Ä –∏–Ω–∫–æ–Ω–µ–ª—å 2.4668" },
  incoloy800: { name: "Incoloy 800H/HT", density: 7940, group: "–ù–∏–∫–µ–ª—å", search: "n08800 n08810 n08811 —Ö–Ω32—Ç –∏–Ω–∫–æ–ª–æ–π 1.4876 1.4958 1.4959" },
  incoloy825: { name: "Incoloy 825", density: 8140, group: "–ù–∏–∫–µ–ª—å", search: "n08825 —Ö–Ω38–≤—Ç –∏–Ω–∫–æ–ª–æ–π 2.4858" },
  hastC276: { name: "Hastelloy C-276", density: 8890, group: "–ù–∏–∫–µ–ª—å", search: "n10276 —Ö–Ω65–º–≤ —Ö–∞—Å—Ç–µ–ª–ª–æ–π 2.4819" },
  hastC22: { name: "Hastelloy C-22", density: 8690, group: "–ù–∏–∫–µ–ª—å", search: "n06022 —Ö–∞—Å—Ç–µ–ª–ª–æ–π 2.4602" },
  /* ‚îÄ‚îÄ –¶–≤–µ—Ç–Ω—ã–µ –º–µ—Ç–∞–ª–ª—ã ‚îÄ‚îÄ */
  aluminum: { name: "–ê–ª—é–º–∏–Ω–∏–π", density: 2710, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "–∞–ª –∞–º–≥ 6061 6063 5052 –¥16 –∞–¥31" },
  copper: { name: "–ú–µ–¥—å", density: 8900, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "–º1 –º2 cu c11000" },
  brass: { name: "–õ–∞—Ç—É–Ω—å", density: 8500, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "–ª63 –ª68 –ª—Å59 cuzn" },
  bronze: { name: "–ë—Ä–æ–Ω–∑–∞", density: 8800, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "–±—Ä–∞–∂ –±—Ä–æ—Ñ –±—Ä–æ–Ω–∑ cusnzn" },
  titanium_gr2: { name: "–¢–∏—Ç–∞–Ω Grade 2", density: 4510, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "–≤—Ç1-0 grade2 r50400 3.7035 —Ç–∏—Ç–∞–Ω" },
  titanium_gr5: { name: "–¢–∏—Ç–∞–Ω Grade 5", density: 4430, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "–≤—Ç6 grade5 r56400 3.7165 ti6al4v —Ç–∏—Ç–∞–Ω" },
  cast_iron: { name: "–ß—É–≥—É–Ω", density: 7200, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "—Å—á —á—É–≥—É–Ω cast iron" },
  zinc: { name: "–¶–∏–Ω–∫", density: 7130, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "—Ü–∏–Ω–∫ zinc zn" },
  lead: { name: "–°–≤–∏–Ω–µ—Ü", density: 11340, group: "–¶–≤–µ—Ç–Ω—ã–µ", search: "—Å–≤–∏–Ω–µ—Ü lead pb" },
};

const METAL_GROUPS = ["–°—Ç–∞–ª—å", "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", "–î—É–ø–ª–µ–∫—Å", "–ù–∏–∫–µ–ª—å", "–¶–≤–µ—Ç–Ω—ã–µ"];

const PROFILES = [
  { id: "rebar", name: "–ê—Ä–º–∞—Ç—É—Ä–∞", short: "–ê—Ä–º–∞—Ç.", dLen: 12 },
  { id: "pipe_round", name: "–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è", short: "–¢—Ä—É–±–∞ –∫—Ä.", dLen: 12 },
  { id: "pipe_profile", name: "–¢—Ä—É–±–∞ –ø—Ä–æ—Ñ–∏–ª—å–Ω–∞—è", short: "–¢—Ä—É–±–∞ –ø—Ä.", dLen: 12 },
  { id: "sheet", name: "–õ–∏—Å—Ç / –ü–æ–ª–æ—Å–∞", short: "–õ–∏—Å—Ç", dLen: null },
  { id: "angle", name: "–£–≥–æ–ª–æ–∫", short: "–£–≥–æ–ª–æ–∫", dLen: 12 },
  { id: "channel", name: "–®–≤–µ–ª–ª–µ—Ä", short: "–®–≤–µ–ª–ª–µ—Ä", dLen: 12 },
  { id: "beam", name: "–î–≤—É—Ç–∞–≤—Ä", short: "–î–≤—É—Ç–∞–≤—Ä", dLen: 12 },
  { id: "circle", name: "–ö—Ä—É–≥ / –ü—Ä—É—Ç–æ–∫", short: "–ö—Ä—É–≥", dLen: 6 },
  { id: "square_bar", name: "–ö–≤–∞–¥—Ä–∞—Ç", short: "–ö–≤–∞–¥—Ä–∞—Ç", dLen: 6 },
  { id: "hex_bar", name: "–®–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫", short: "–®–µ—Å—Ç–∏–≥—Ä.", dLen: 6 },
];

const PARAM_DEFS = {
  diameter: { label: "–î–∏–∞–º–µ—Ç—Ä", unit: "–º–º", sym: "D" },
  wall: { label: "–°—Ç–µ–Ω–∫–∞", unit: "–º–º", sym: "t" },
  sideA: { label: "–°—Ç–æ—Ä–æ–Ω–∞ A", unit: "–º–º", sym: "A" },
  sideB: { label: "–°—Ç–æ—Ä–æ–Ω–∞ B", unit: "–º–º", sym: "B" },
  side: { label: "–°—Ç–æ—Ä–æ–Ω–∞", unit: "–º–º", sym: "a" },
  width: { label: "–®–∏—Ä–∏–Ω–∞", unit: "–º–º", sym: "W" },
  thickness: { label: "–¢–æ–ª—â–∏–Ω–∞", unit: "–º–º", sym: "t" },
  height: { label: "–í—ã—Å–æ—Ç–∞", unit: "–º–º", sym: "H" },
  shelfWidth: { label: "–ü–æ–ª–∫–∞ A", unit: "–º–º", sym: "a" },
  shelfB: { label: "–ü–æ–ª–∫–∞ B", unit: "–º–º", sym: "b" },
  webThickness: { label: "–°—Ç–µ–Ω–∫–∞", unit: "–º–º", sym: "s" },
  flangeThickness: { label: "–ü–æ–ª–∫–∞ —Ç–æ–ª—â.", unit: "–º–º", sym: "t" },
};

const PARAMS_MAP = {
  pipe_round: ["diameter", "wall"],
  pipe_profile: ["sideA", "sideB", "wall"],
  circle: ["diameter"],
  rebar: ["diameter"],
  square_bar: ["side"],
  hex_bar: ["side"],
  sheet: ["width", "thickness"],
  angle: ["shelfWidth", "shelfB", "thickness"],
  channel: ["height", "shelfWidth", "webThickness", "flangeThickness"],
  beam: ["height", "shelfWidth", "webThickness", "flangeThickness"],
};

function calcArea(id, p) {
  switch (id) {
    case "pipe_round": { const R = p.diameter / 2, r = R - p.wall; return r <= 0 ? Math.PI * R * R : Math.PI * (R * R - r * r); }
    case "pipe_profile": { const A = p.sideA, B = p.sideB, t = p.wall; const R = 2*t, r = R - t; const str = 2*(Math.max(0, A - 2*R) + Math.max(0, B - 2*R))*t; return str + Math.PI*(R*R - r*r); }
    case "circle": return Math.PI * (p.diameter / 2) ** 2;
    case "rebar": return Math.PI * (p.diameter / 2) ** 2;
    case "square_bar": return p.side * p.side;
    case "hex_bar": return (Math.sqrt(3) / 2) * p.side ** 2;
    case "sheet": return p.width * p.thickness;
    case "angle": { const t = p.thickness, a = p.shelfWidth, b = p.shelfB || a; const Rmap = {20:2.4,25:2.1,28:2.4,30:2.4,32:2.8,35:2.8,40:3.2,45:3.1,50:3.4,56:4.0,60:4.4,63:4.4,65:4.4,70:4.9,75:5.6,80:5.6,90:6.3,100:7.5,110:7.5,120:9.0,125:9.0,140:10.0,150:10.0,160:11.0,180:12.0,200:13.0,250:16.0}; const R = Rmap[a] || (a * 0.07); return (a + b - t) * t + (4 - Math.PI) / 2 * R * R; }
    case "channel": { const { height: H, shelfWidth: b, webThickness: tw, flangeThickness: tf } = p; const R = 0.024 * H + 4.8, r = 0.01 * H + 2.0; return (H - 2 * tf) * tw + 2 * b * tf + (4 - Math.PI) / 2 * R * R - (4 - Math.PI) * r * r; }
    case "beam": { const { height: H, shelfWidth: b, webThickness: tw, flangeThickness: tf } = p; const R = 1.7 * tw; return (H - 2 * tf) * tw + 2 * b * tf + (4 - Math.PI) * R * R; }
    default: return 0;
  }
}

function MetalPicker({ value, onChange, mob }) {
  const [open, setOpen] = useState(false);
  const [q, setQ] = useState("");
  const ref = useRef(null);
  const cur = METALS[value];

  useEffect(() => {
    if (!open) return;
    const h = (e) => { if (ref.current && !ref.current.contains(e.target)) setOpen(false); };
    document.addEventListener("mousedown", h); document.addEventListener("touchstart", h);
    return () => { document.removeEventListener("mousedown", h); document.removeEventListener("touchstart", h); };
  }, [open]);

  const filtered = useMemo(() => {
    const ql = q.toLowerCase().replace(/[^a-z–∞-—è—ë0-9.\-]/g, "");
    if (!ql) return null;
    return Object.entries(METALS).filter(([k, m]) => {
      const hay = (m.name + " " + m.group + " " + (m.search || "") + " " + m.density).toLowerCase();
      return hay.includes(ql);
    });
  }, [q]);

  const select = (k) => { onChange(k); setOpen(false); setQ(""); };

  const groupColor = { "–°—Ç–∞–ª—å": "#a0aec0", "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞": "#52b788", "–î—É–ø–ª–µ–∫—Å": "#e8a838", "–ù–∏–∫–µ–ª—å": "#c084fc", "–¶–≤–µ—Ç–Ω—ã–µ": "#60a5fa" };

  const renderItem = ([k, m]) => (
    <div key={k} onClick={() => select(k)} style={{
      padding: "8px 12px", cursor: "pointer", display: "flex", justifyContent: "space-between", alignItems: "center",
      background: k === value ? "rgba(82,183,136,0.12)" : "transparent", borderLeft: `3px solid ${groupColor[m.group] || "#52b788"}`,
    }}
      onMouseEnter={e => { e.currentTarget.style.background = "rgba(82,183,136,0.08)"; }}
      onMouseLeave={e => { e.currentTarget.style.background = k === value ? "rgba(82,183,136,0.12)" : "transparent"; }}>
      <span style={{ fontSize: 13, fontWeight: k === value ? 700 : 400 }}>{m.name}</span>
      <span style={{ fontSize: 11, color: "rgba(255,255,255,0.3)", fontFamily: "'JetBrains Mono',monospace" }}>{m.density}</span>
    </div>
  );

  return (
    <div ref={ref} style={{ position: "relative" }}>
      <div onClick={() => { setOpen(!open); setQ(""); }} style={{
        width: "100%", padding: "10px 12px", background: "rgba(255,255,255,0.06)", border: open ? "1px solid rgba(82,183,136,0.5)" : "1px solid rgba(255,255,255,0.1)",
        borderRadius: 8, color: "#fff", fontSize: 14, fontFamily: "'Nunito',sans-serif", fontWeight: 600, cursor: "pointer",
        display: "flex", justifyContent: "space-between", alignItems: "center",
      }}>
        <span>
          <span style={{ display: "inline-block", width: 8, height: 8, borderRadius: 4, background: groupColor[cur?.group] || "#52b788", marginRight: 8 }}></span>
          {cur?.name}
          <span style={{ fontSize: 11, color: "rgba(255,255,255,0.35)", marginLeft: 6 }}>({cur?.density} –∫–≥/–º¬≥)</span>
        </span>
        <span style={{ fontSize: 10, color: "rgba(255,255,255,0.3)" }}>{open ? "‚ñ≤" : "‚ñº"}</span>
      </div>

      {open && (
        <div style={{
          position: "absolute", top: "100%", left: 0, right: 0, zIndex: 999,
          background: "#1a2f22", border: "1px solid rgba(82,183,136,0.3)", borderRadius: 10,
          marginTop: 4, maxHeight: mob ? "50vh" : 360, overflow: "hidden", display: "flex", flexDirection: "column",
          boxShadow: "0 12px 40px rgba(0,0,0,0.5)",
        }}>
          <div style={{ padding: "8px 10px", borderBottom: "1px solid rgba(255,255,255,0.06)" }}>
            <input autoFocus type="text" value={q} onChange={e => setQ(e.target.value)}
              placeholder="üîç 316, Inconel, –¥—É–ø–ª–µ–∫—Å, 7850..."
              style={{
                width: "100%", padding: "8px 10px", background: "rgba(255,255,255,0.08)", border: "1px solid rgba(255,255,255,0.1)",
                borderRadius: 6, color: "#fff", fontSize: 13, fontFamily: "'Nunito',sans-serif", outline: "none",
              }} />
          </div>
          <div style={{ overflowY: "auto", flex: 1 }}>
            {filtered ? (
              filtered.length > 0 ? filtered.map(renderItem) : (
                <div style={{ padding: 16, textAlign: "center", color: "rgba(255,255,255,0.3)", fontSize: 12 }}>–ù–µ –Ω–∞–π–¥–µ–Ω–æ</div>
              )
            ) : (
              METAL_GROUPS.map(g => (
                <div key={g}>
                  <div style={{ padding: "6px 12px", fontSize: 10, fontWeight: 800, color: groupColor[g] || "#52b788", textTransform: "uppercase", letterSpacing: "0.1em", background: "rgba(255,255,255,0.02)" }}>{g}</div>
                  {Object.entries(METALS).filter(([, m]) => m.group === g).map(renderItem)}
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  );
}

function ProfileIcon({ id, active }) {
  const s = 30, cx = s / 2, cy = s / 2;
  const cl = active ? "#fff" : "#52b788";
  const fl = active ? "rgba(255,255,255,0.1)" : "rgba(82,183,136,0.08)";
  const icons = {
    pipe_round: <g><circle cx={cx} cy={cy} r={12} fill={fl} stroke={cl} strokeWidth={1.2} /><circle cx={cx} cy={cy} r={7} fill="none" stroke={cl} strokeWidth={1} /></g>,
    pipe_profile: <g><rect x={cx-13} y={cy-9} width={26} height={18} rx={2} fill={fl} stroke={cl} strokeWidth={1.2} /><rect x={cx-9} y={cy-5} width={18} height={10} rx={1} fill="none" stroke={cl} strokeWidth={1} /></g>,
    circle: <circle cx={cx} cy={cy} r={12} fill={fl} stroke={cl} strokeWidth={1.2} />,
    rebar: <g><circle cx={cx} cy={cy} r={10} fill={fl} stroke={cl} strokeWidth={1.2} />{[0,1,2,3,4,5,6,7,8,9].map(i => { const a=(i/10)*Math.PI*2; return <line key={i} x1={cx+9*Math.cos(a)} y1={cy+9*Math.sin(a)} x2={cx+13*Math.cos(a)} y2={cy+13*Math.sin(a)} stroke={cl} strokeWidth={1.2} strokeLinecap="round" />; })}</g>,
    square_bar: <rect x={cx-11} y={cy-11} width={22} height={22} fill={fl} stroke={cl} strokeWidth={1.2} />,
    hex_bar: (() => { const r=12; const pts=[0,1,2,3,4,5].map(i=>{const a=Math.PI/6+(i*Math.PI)/3;return`${cx+r*Math.cos(a)},${cy+r*Math.sin(a)}`;}).join(" "); return <polygon points={pts} fill={fl} stroke={cl} strokeWidth={1.2} />; })(),
    sheet: <rect x={cx-14} y={cy-3} width={28} height={6} fill={fl} stroke={cl} strokeWidth={1.2} />,
    angle: <path d={`M${cx-9} ${cy-11}L${cx-9} ${cy+11}L${cx+11} ${cy+11}L${cx+11} ${cy+6}L${cx-3} ${cy+6}L${cx-3} ${cy-11}Z`} fill={fl} stroke={cl} strokeWidth={1.2} />,
    channel: <path d={`M${cx-7} ${cy-12}L${cx+9} ${cy-12}L${cx+9} ${cy-6}L${cx-1} ${cy-6}L${cx-1} ${cy+6}L${cx+9} ${cy+6}L${cx+9} ${cy+12}L${cx-7} ${cy+12}Z`} fill={fl} stroke={cl} strokeWidth={1.2} />,
    beam: <path d={`M${cx-9} ${cy-12}L${cx+9} ${cy-12}L${cx+9} ${cy-6}L${cx+3} ${cy-6}L${cx+3} ${cy+6}L${cx+9} ${cy+6}L${cx+9} ${cy+12}L${cx-9} ${cy+12}L${cx-9} ${cy+6}L${cx-3} ${cy+6}L${cx-3} ${cy-6}L${cx-9} ${cy-6}Z`} fill={fl} stroke={cl} strokeWidth={1.2} />,
  };
  return <svg width={s} height={s} viewBox={`0 0 ${s} ${s}`}>{icons[id]}</svg>;
}

function TechDrawing({ profileId, size }) {
  const s = size || 160, w = s, h = s, mx = w / 2, my = h / 2;
  const sc = s / 160;
  const hf = { fill: "url(#hD)", stroke: "#52b788", strokeWidth: 1.5 };
  const dm = { stroke: "#8ab4a0", strokeWidth: 0.7, markerEnd: "url(#aE)", markerStart: "url(#aS)" };
  const dl = { stroke: "#8ab4a0", strokeWidth: 0.5, strokeDasharray: "3,2" };
  const lb = { fill: "#52b788", fontSize: 11, fontFamily: "Nunito,sans-serif", fontWeight: 700, textAnchor: "middle" };
  const ls = { ...lb, fontSize: 9 };
  const Defs = <defs>
    <pattern id="hD" width="5" height="5" patternUnits="userSpaceOnUse" patternTransform="rotate(45)"><line x1="0" y1="0" x2="0" y2="5" stroke="#2d6a4f" strokeWidth="0.8" opacity="0.35" /></pattern>
    <marker id="aE" markerWidth="5" markerHeight="5" refX="4" refY="2.5" orient="auto"><path d="M0,0L5,2.5L0,5" fill="none" stroke="#8ab4a0" strokeWidth="0.7" /></marker>
    <marker id="aS" markerWidth="5" markerHeight="5" refX="1" refY="2.5" orient="auto"><path d="M5,0L0,2.5L5,5" fill="none" stroke="#8ab4a0" strokeWidth="0.7" /></marker>
  </defs>;
  // Use fixed 160 viewBox and scale via SVG
  const M = 80, MY = 84;
  const drawings = {
    pipe_round: <g><circle cx={M} cy={MY} r={44} {...hf} /><circle cx={M} cy={MY} r={30} fill="#0f1f15" stroke="#52b788" strokeWidth="1.5" /><line x1={M-44} y1={30} x2={M+44} y2={30} {...dm} /><line x1={M-44} y1={40} x2={M-44} y2={26} {...dl} /><line x1={M+44} y1={40} x2={M+44} y2={26} {...dl} /><text x={M} y={25} {...lb}>D</text><line x1={M+30} y1={MY} x2={M+44} y2={MY} {...dm} /><text x={M+37} y={MY-7} {...ls}>t</text></g>,
    pipe_profile: <g><rect x={32} y={52} width={96} height={64} rx={3} {...hf} /><rect x={43} y={63} width={74} height={42} rx={2} fill="#0f1f15" stroke="#52b788" strokeWidth="1.5" /><line x1={32} y1={128} x2={128} y2={128} {...dm} /><line x1={32} y1={116} x2={32} y2={132} {...dl} /><line x1={128} y1={116} x2={128} y2={132} {...dl} /><text x={M} y={141} {...lb}>A</text><line x1={140} y1={52} x2={140} y2={116} {...dm} /><line x1={128} y1={52} x2={144} y2={52} {...dl} /><line x1={128} y1={116} x2={144} y2={116} {...dl} /><text x={150} y={88} {...lb}>B</text><line x1={32} y1={41} x2={43} y2={41} {...dm} /><text x={38} y={37} {...ls}>t</text></g>,
    circle: <g><circle cx={M} cy={MY} r={44} {...hf} /><line x1={M-44} y1={30} x2={M+44} y2={30} {...dm} /><line x1={M-44} y1={40} x2={M-44} y2={26} {...dl} /><line x1={M+44} y1={40} x2={M+44} y2={26} {...dl} /><text x={M} y={25} {...lb}>D</text></g>,
    rebar: <g><circle cx={M} cy={MY} r={38} {...hf} />{[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15].map(i=>{const a=(i/16)*Math.PI*2;return <line key={i} x1={M+36*Math.cos(a)} y1={MY+36*Math.sin(a)} x2={M+44*Math.cos(a)} y2={MY+44*Math.sin(a)} stroke="#52b788" strokeWidth="1.8" strokeLinecap="round" />;})}<line x1={M-44} y1={30} x2={M+44} y2={30} {...dm} /><line x1={M-44} y1={40} x2={M-44} y2={26} {...dl} /><line x1={M+44} y1={40} x2={M+44} y2={26} {...dl} /><text x={M} y={25} {...lb}>D</text></g>,
    square_bar: <g><rect x={44} y={48} width={72} height={72} {...hf} /><line x1={44} y1={132} x2={116} y2={132} {...dm} /><line x1={44} y1={120} x2={44} y2={136} {...dl} /><line x1={116} y1={120} x2={116} y2={136} {...dl} /><text x={M} y={145} {...lb}>a</text></g>,
    hex_bar: (()=>{const r=40;const pts=[0,1,2,3,4,5].map(i=>{const a=Math.PI/6+(i*Math.PI)/3;return`${M+r*Math.cos(a)},${MY+r*Math.sin(a)}`;}).join(" ");const xO=r*Math.cos(Math.PI/6);return <g><polygon points={pts} {...hf} /><line x1={M-xO} y1={134} x2={M+xO} y2={134} {...dm} /><line x1={M-xO} y1={MY+r*0.5+2} x2={M-xO} y2={138} {...dl} /><line x1={M+xO} y1={MY+r*0.5+2} x2={M+xO} y2={138} {...dl} /><text x={M} y={147} {...lb}>S</text></g>;})(),
    sheet: <g><rect x={20} y={74} width={120} height={20} {...hf} /><line x1={20} y1={106} x2={140} y2={106} {...dm} /><line x1={20} y1={94} x2={20} y2={110} {...dl} /><line x1={140} y1={94} x2={140} y2={110} {...dl} /><text x={M} y={119} {...lb}>W</text><line x1={150} y1={74} x2={150} y2={94} {...dm} /><line x1={140} y1={74} x2={154} y2={74} {...dl} /><line x1={140} y1={94} x2={154} y2={94} {...dl} /><text x={150} y={69} {...ls}>t</text></g>,
    angle: <g><path d={`M52 40L52 120L120 120L120 108L65 108L65 40Z`} {...hf} /><line x1={52} y1={134} x2={120} y2={134} {...dm} /><line x1={52} y1={120} x2={52} y2={138} {...dl} /><line x1={120} y1={120} x2={120} y2={138} {...dl} /><text x={86} y={147} {...lb}>b</text><line x1={38} y1={40} x2={38} y2={120} {...dm} /><line x1={52} y1={40} x2={34} y2={40} {...dl} /><line x1={52} y1={120} x2={34} y2={120} {...dl} /><text x={30} y={82} {...ls}>a</text><line x1={52} y1={30} x2={65} y2={30} {...dm} /><line x1={52} y1={40} x2={52} y2={26} {...dl} /><line x1={65} y1={40} x2={65} y2={26} {...dl} /><text x={59} y={25} {...ls}>t</text></g>,
    channel: <g><path d={`M58 38L108 38L108 50L72 50L72 110L108 110L108 122L58 122Z`} {...hf} /><line x1={44} y1={38} x2={44} y2={122} {...dm} /><line x1={58} y1={38} x2={40} y2={38} {...dl} /><line x1={58} y1={122} x2={40} y2={122} {...dl} /><text x={34} y={84} {...lb}>H</text><line x1={58} y1={26} x2={108} y2={26} {...dm} /><line x1={58} y1={38} x2={58} y2={22} {...dl} /><line x1={108} y1={38} x2={108} y2={22} {...dl} /><text x={83} y={22} {...lb}>b</text><line x1={58} y1={80} x2={72} y2={80} {...dm} /><text x={65} y={76} {...ls}>s</text><line x1={120} y1={110} x2={120} y2={122} {...dm} /><line x1={108} y1={110} x2={124} y2={110} {...dl} /><line x1={108} y1={122} x2={124} y2={122} {...dl} /><text x={130} y={119} {...ls}>t</text></g>,
    beam: <g><path d={`M50 38L110 38L110 50L86 50L86 110L110 110L110 122L50 122L50 110L74 110L74 50L50 50Z`} {...hf} /><line x1={36} y1={38} x2={36} y2={122} {...dm} /><line x1={50} y1={38} x2={32} y2={38} {...dl} /><line x1={50} y1={122} x2={32} y2={122} {...dl} /><text x={26} y={84} {...lb}>H</text><line x1={50} y1={26} x2={110} y2={26} {...dm} /><line x1={50} y1={38} x2={50} y2={22} {...dl} /><line x1={110} y1={38} x2={110} y2={22} {...dl} /><text x={M} y={22} {...lb}>b</text><line x1={74} y1={80} x2={86} y2={80} {...dm} /><text x={M} y={76} {...ls}>s</text><line x1={122} y1={110} x2={122} y2={122} {...dm} /><line x1={110} y1={110} x2={126} y2={110} {...dl} /><line x1={110} y1={122} x2={126} y2={122} {...dl} /><text x={132} y={119} {...ls}>t</text></g>,
  };
  return <svg width={w} height={h} viewBox="0 0 160 160" style={{ display: "block" }}>{Defs}{drawings[profileId]}</svg>;
}

function fmt(n) {
  if (!n || isNaN(n) || !isFinite(n)) return "‚Äî";
  if (n < 0.001) return "< 0.001";
  if (n >= 1000) return n.toFixed(1).replace(/\B(?=(\d{3})+(?!\d))/g, " ");
  if (n >= 100) return n.toFixed(2);
  if (n >= 1) return n.toFixed(3);
  return n.toFixed(4);
}

function useIsMobile(bp = 640) {
  const [m, setM] = useState(typeof window !== "undefined" ? window.innerWidth < bp : false);
  useEffect(() => { const h = () => setM(window.innerWidth < bp); window.addEventListener("resize", h); return () => window.removeEventListener("resize", h); }, [bp]);
  return m;
}

function MetalCalculator() {
  const mob = useIsMobile(640);
  const [metal, setMetal] = useState("steel");
  const [pid, setPid] = useState("pipe_round");
  const [params, setParams] = useState({});
  const [length, setLength] = useState("12");
  const [weight, setWeight] = useState("");
  const [lastE, setLastE] = useState("length");
  const [hist, setHist] = useState([]);
  const [qty, setQty] = useState("1");
  const [copied, setCopied] = useState(false);
  const [showImport, setShowImport] = useState(false);
  const [importText, setImportText] = useState("");
  const [importTab, setImportTab] = useState("text"); // text | file | photo
  const [importStatus, setImportStatus] = useState(""); // loading message
  const [importError, setImportError] = useState("");
  const fileRef = useRef(null);
  const galleryRef = useRef(null);
  const cameraRef = useRef(null);
  const fr = useRef(null);

  const prof = PROFILES.find(p => p.id === pid);
  const pKeys = PARAMS_MAP[pid] || [];
  const dens = METALS[metal].density;

  useEffect(() => { setParams({}); setWeight(""); setLength(prof?.dLen ? String(prof.dLen) : ""); setLastE("length"); setTimeout(() => fr.current?.focus(), 50); }, [pid]);

  const fixNum = (v) => v.replace(/[,ÿåŸ´‚∏¥]/g, ".").replace(/\s/g, "");
  /* Auto-sync pairs: B follows A until user manually edits B */
  const syncPairs = { shelfWidth: "shelfB", sideA: "sideB" }; /* A ‚Üí B */
  const syncTargets = new Set(["shelfB", "sideB"]); /* B fields */
  const [bEdited, setBEdited] = useState({});
  const setP = useCallback((k, v) => {
    const fv = fixNum(v);
    setParams(prev => {
      const next = { ...prev, [k]: fv };
      /* If A changed and B not manually edited ‚Üí sync B = A */
      if (syncPairs[k] && !bEdited[syncPairs[k]]) next[syncPairs[k]] = fv;
      /* If B changed ‚Üí mark as manually edited */
      if (syncTargets.has(k)) setBEdited(prev2 => ({ ...prev2, [k]: true }));
      return next;
    });
  }, [bEdited]);
  /* Reset B-edited flags when switching profiles */
  useEffect(() => { setBEdited({}); }, [pid]);
  const allF = pKeys.every(k => { if (syncTargets.has(k)) return true; return parseFloat(params[k]) > 0; });
  const wpm = useMemo(() => { if (!allF) return 0; const np = {}; pKeys.forEach(k => { const v = parseFloat(params[k]); if (v > 0) { np[k] = v; } else if (syncTargets.has(k)) { /* B defaults to A */ const aKey = Object.entries(syncPairs).find(([, b]) => b === k)?.[0]; np[k] = parseFloat(params[aKey]) || 0; } else { np[k] = 0; } }); const a = calcArea(pid, np); return a > 0 ? (a / 1e6) * dens : 0; }, [pid, params, dens, allF, pKeys]);

  const hLen = (v) => { const v2 = fixNum(v); setLength(v2); setLastE("length"); if (wpm > 0 && parseFloat(v2) > 0) setWeight((wpm * parseFloat(v2)).toFixed(2)); else setWeight(""); };
  const hWt = (v) => { const v2 = fixNum(v); setWeight(v2); setLastE("weight"); if (wpm > 0 && parseFloat(v2) > 0) setLength((parseFloat(v2) / wpm).toFixed(3)); else setLength(""); };
  useEffect(() => { if (wpm <= 0) return; if (lastE === "length" && parseFloat(length) > 0) setWeight((wpm * parseFloat(length)).toFixed(2)); else if (lastE === "weight" && parseFloat(weight) > 0) setLength((parseFloat(weight) / wpm).toFixed(3)); }, [wpm]);

  const canAdd = parseFloat(length) > 0 && parseFloat(weight) > 0 && wpm > 0;
  const addH = () => { if (!canAdd) return; const q = parseInt(qty) || 1, w = parseFloat(weight); setHist(prev => [{ id: Date.now(), prof: prof.name, metal: METALS[metal].name, metalKey: metal, profileId: pid, params: { ...params }, pk: [...pKeys], len: parseFloat(length), qty: q, tw: w * q }, ...prev]); };
  const rmH = (id) => setHist(prev => prev.filter(e => e.id !== id));
  const loadH = (e) => { setMetal(e.metalKey); setPid(e.profileId); setTimeout(() => { const np = {}; e.pk.forEach(k => { np[k] = e.params[k]; }); setParams(np); setLength(String(e.len)); setQty(String(e.qty)); setLastE("length"); }, 60); };
  const [editId, setEditId] = useState(null);
  const [editLen, setEditLen] = useState("");
  const [editQty, setEditQty] = useState("");
  const startEdit = (e, ev) => { ev.stopPropagation(); setEditId(e.id); setEditLen(String(e.len)); setEditQty(String(e.qty)); };
  const saveEdit = (e) => {
    const newLen = parseFloat(editLen) || e.len;
    const newQty = parseInt(editQty) || e.qty;
    /* Recalculate weight */
    const np = {}; e.pk.forEach(k => { np[k] = parseFloat(e.params[k]) || 0; });
    const area = calcArea(e.profileId, np);
    const wpmE = area > 0 ? (area / 1e6) * METALS[e.metalKey].density : 0;
    const newTw = wpmE * newLen * newQty;
    setHist(prev => prev.map(h => h.id === e.id ? { ...h, len: newLen, qty: newQty, tw: newTw } : h));
    setEditId(null);
  };
  const totW = hist.reduce((s, e) => s + e.tw, 0);
  const copyTSV = () => { const h = "–ü—Ä–æ—Ñ–∏–ª—å\t–ú–µ—Ç–∞–ª–ª\t–†–∞–∑–º–µ—Ä—ã\t–î–ª–∏–Ω–∞ –º\t–ö–æ–ª-–≤–æ\t–í–µ—Å –∫–≥"; const rows = hist.map(e => `${e.prof}\t${e.metal}\t${e.pk.map(k => e.params[k]).join("√ó")}\t${e.len}\t${e.qty}\t${e.tw.toFixed(2)}`); navigator.clipboard.writeText([h, ...rows, `–ò–¢–û–ì–û\t\t\t\t\t${totW.toFixed(2)}`].join("\n")).then(() => { setCopied(true); setTimeout(() => setCopied(false), 2000); }); };

  const importExample = "–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;720;7.5;12;1\n–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;219.1;12.7;10;2";

  /* Extract dimensions from description */
  const extractDims = (desc) => {
    // pattern: (D x T) or (DxT) ‚Äî in parentheses (pipe, profile tube)
    let m = desc.match(/\((\d+[\.,]?\d*)\s*[x—Ö√ó]\s*(\d+[\.,]?\d*)\)/i);
    if (m) return [parseFloat(m[1].replace(",", ".")), parseFloat(m[2].replace(",", "."))];
    // pattern: DxT without parentheses
    m = desc.match(/(\d+[\.,]?\d*)\s*[x—Ö√ó]\s*(\d+[\.,]?\d*)/i);
    if (m) return [parseFloat(m[1].replace(",", ".")), parseFloat(m[2].replace(",", "."))];
    // single dimension for circle/rebar/square/hex: "–ö—Ä—É–≥ 5–º–º" or "–ö—Ä—É–≥ (–ø—Ä—É—Ç–æ–∫) 500–º–º" or "d=25"
    m = desc.match(/(?:–∫—Ä—É–≥|–ø—Ä—É—Ç–æ–∫|–∞—Ä–º–∞—Ç—É—Ä|rod|bar|circle|rebar|–∫–≤–∞–¥—Ä–∞—Ç|square|—à–µ—Å—Ç–∏–≥—Ä|hex)[^0-9]*(\d+[\.,]?\d*)\s*–º–º/i);
    if (m) return [parseFloat(m[1].replace(",", "."))];
    m = desc.match(/(?:–∫—Ä—É–≥|–ø—Ä—É—Ç–æ–∫|–∞—Ä–º–∞—Ç—É—Ä|rod|bar|circle|rebar|–∫–≤–∞–¥—Ä–∞—Ç|square|—à–µ—Å—Ç–∏–≥—Ä|hex)[^0-9]*[dD–¥–î]\s*=?\s*(\d+[\.,]?\d*)/i);
    if (m) return [parseFloat(m[1].replace(",", "."))];
    // sheet/plate: "–õ–∏—Å—Ç 5–º–º 1000x2000" or "–õ–∏—Å—Ç 1000x5"
    m = desc.match(/(?:–ª–∏—Å—Ç|sheet|plate|–ø–æ–ª–æ—Å)[^0-9]*(\d+[\.,]?\d*)\s*[x—Ö√ó]\s*(\d+[\.,]?\d*)/i);
    if (m) return [parseFloat(m[1].replace(",", ".")), parseFloat(m[2].replace(",", "."))];
    return null;
  };

  /* Detect profile type from description */
  const detectProfile = (desc) => {
    const d = desc.toLowerCase();
    if (d.includes("—Ç—Ä—É–±") && (d.includes("–ø—Ä–æ—Ñ–∏–ª") || d.includes("–ø—Ä—è–º–æ—É–≥") || d.includes("–∫–≤–∞–¥—Ä–∞—Ç–Ω"))) return PROFILES.find(p => p.id === "pipe_profile");
    if (d.includes("pipe") || d.includes("—Ç—Ä—É–±") || d.includes("nipple") || d.includes("–Ω–∏–ø–ø–µ–ª")) return PROFILES.find(p => p.id === "pipe_round");
    if (d.includes("–∞—Ä–º–∞—Ç") || d.includes("rebar")) return PROFILES.find(p => p.id === "rebar");
    if (d.includes("–∫—Ä—É–≥") || d.includes("–ø—Ä—É—Ç–æ–∫") || d.includes("circle") || d.includes("rod") || d.includes("round bar")) return PROFILES.find(p => p.id === "circle");
    if (d.includes("–ª–∏—Å—Ç") || d.includes("sheet") || d.includes("plate") || d.includes("–ø–æ–ª–æ—Å")) return PROFILES.find(p => p.id === "sheet");
    if (d.includes("—É–≥–æ–ª") || d.includes("angle")) return PROFILES.find(p => p.id === "angle");
    if (d.includes("—à–≤–µ–ª–ª") || d.includes("channel")) return PROFILES.find(p => p.id === "channel");
    if (d.includes("–¥–≤—É—Ç–∞–≤—Ä") || d.includes("beam")) return PROFILES.find(p => p.id === "beam");
    if (d.includes("—à–µ—Å—Ç–∏–≥—Ä") || d.includes("hex")) return PROFILES.find(p => p.id === "hex_bar");
    if (d.includes("–∫–≤–∞–¥—Ä–∞—Ç") || d.includes("square")) return PROFILES.find(p => p.id === "square_bar");
    return null; // unknown
  };

  /* Detect metal from description */
  const detectMetal = (desc) => {
    const d = desc.toLowerCase();
    /* Nickel alloys */
    if (/inconel|–∏–Ω–∫–æ–Ω–µ–ª—å/i.test(desc)) { if (/718/i.test(desc)) return "inconel718"; if (/600/i.test(desc)) return "inconel600"; return "inconel625"; }
    if (/monel|–º–æ–Ω–µ–ª—å/i.test(desc)) return "monel400";
    if (/hastelloy|—Ö–∞—Å—Ç–µ–ª–ª–æ–π/i.test(desc)) { if (/c-?22/i.test(desc)) return "hastC22"; return "hastC276"; }
    if (/incoloy|–∏–Ω–∫–æ–ª–æ–π/i.test(desc)) { if (/825/i.test(desc)) return "incoloy825"; return "incoloy800"; }
    if (/n06625|n07718|n06600|n10276|n08825/i.test(desc)) return "inconel625";
    /* Duplex */
    if (/duplex|–¥—É–ø–ª–µ–∫—Å|2205|s32205|s31803/i.test(desc)) return "dup2205";
    if (/superduplex|2507|s32750/i.test(desc)) return "dup2507";
    /* Specific stainless grades */
    if (/316|08—Ö17–Ω13–º2/i.test(desc)) return "ss316";
    if (/310s?|10—Ö23–Ω18/i.test(desc)) return "ss310";
    if (/321|12—Ö18–Ω10—Ç/i.test(desc)) return "ss321";
    if (/347|08—Ö18–Ω12–±/i.test(desc)) return "ss347";
    if (/304|08—Ö18–Ω10[^—Ç]/i.test(desc)) return "ss304";
    if (d.includes("–Ω–µ—Ä–∂") || d.includes("stainless") || /tp304|tp316|f316|f321/i.test(desc)) return "ss304";
    /* Other */
    if (d.includes("–∞–ª—é–º–∏–Ω") || d.includes("alumin") || /6061|6063|5052/i.test(desc)) return "aluminum";
    if (d.includes("–º–µ–¥—å") || d.includes("copper")) return "copper";
    if (d.includes("–ª–∞—Ç—É–Ω—å") || d.includes("brass")) return "brass";
    if (d.includes("—Ç–∏—Ç–∞–Ω") || d.includes("titan")) return "titanium_gr2";
    return "steel";
  };

  const buildEntry = (desc, qtyVal, lenVal) => {
    const dims = extractDims(desc);
    if (!dims) return null;
    const prof = detectProfile(desc);
    if (!prof) return null;
    const metalKey = detectMetal(desc);
    const pk = PARAMS_MAP[prof.id];
    const po = {};
    pk.forEach((k, i) => { po[k] = dims[i] !== undefined ? String(dims[i]) : "0"; });
    const np = {};
    pk.forEach(k => { np[k] = parseFloat(po[k]) || 0; });
    const d = METALS[metalKey].density;
    const area = calcArea(prof.id, np);
    const w = area > 0 ? (area / 1e6) * d : 0;
    const tw = w * lenVal * qtyVal;
    if (tw <= 0) return null;
    return {
      id: Date.now() + Math.random(), prof: prof.name, metal: METALS[metalKey].name, metalKey,
      profileId: prof.id, params: po, pk: [...pk], len: lenVal, qty: qtyVal, tw,
      desc: desc.trim(),
    };
  };

  const parseImport = (text) => {
    const rawLines = text.trim().split("\n").map(l => l.trim()).filter(l => l);
    const newItems = [];

    /* Strategy 1: Try CSV/TSV (semicolon or tab separated, each line has 4+ parts) */
    const csvLines = rawLines.filter(l => l.split(/[;\t]/).length >= 4);
    if (csvLines.length > 0 && csvLines.length >= rawLines.length * 0.5) {
      for (const line of csvLines) {
        const parts = line.split(/[;\t]/).map(s => s.trim());
        if (parts.length < 4) continue;
        let profName = parts[0] || "–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è";
        let metalName = parts.length >= 6 ? parts[1] : "–°—Ç–∞–ª—å";
        let dims2, lv, qv;
        if (parts.length >= 6) { dims2 = parts.slice(2, parts.length - 2).map(Number); lv = parseFloat(parts[parts.length - 2]) || 12; qv = parseInt(parts[parts.length - 1]) || 1; }
        else if (parts.length === 5) { dims2 = parts.slice(1, 3).map(Number); lv = parseFloat(parts[3]) || 12; qv = parseInt(parts[4]) || 1; }
        else { dims2 = parts.slice(1).map(Number); lv = 12; qv = 1; }
        const pm = PROFILES.find(p => p.name.toLowerCase().includes(profName.toLowerCase())) || PROFILES[0];
        const mm2 = Object.entries(METALS).find(([k, v]) => v.name.toLowerCase().includes(metalName.toLowerCase()));
        const mk = mm2 ? mm2[0] : "steel"; const d = METALS[mk].density; const pk = PARAMS_MAP[pm.id];
        const po = {}; pk.forEach((k, i) => { po[k] = dims2[i] !== undefined ? String(dims2[i]) : "0"; });
        const np = {}; pk.forEach(k => { np[k] = parseFloat(po[k]) || 0; });
        const area = calcArea(pm.id, np); const w = area > 0 ? (area / 1e6) * d : 0; const tw = w * lv * qv;
        if (tw > 0) newItems.push({ id: Date.now() + Math.random(), prof: pm.name, metal: METALS[mk].name, metalKey: mk, profileId: pm.id, params: po, pk: [...pk], len: lv, qty: qv, tw });
      }
      if (newItems.length > 0) { setHist(prev => [...newItems, ...prev]); setShowImport(false); setImportText(""); return; }
    }

    /* Strategy 2: Multi-line paste from Word/PDF table */
    /* First pass: normalize ‚Äî merge lines and identify blocks */
    /* Pattern: row_number ‚Üí description(DxT) ‚Üí UOM ‚Üí value */
    
    /* Collect all description lines with their positions */
    const descEntries = [];
    for (let k = 0; k < rawLines.length; k++) {
      if (extractDims(rawLines[k])) {
        descEntries.push({ idx: k, desc: rawLines[k] });
      }
    }

    /* For each description, look for UOM+value: first on same line, then between lines */
    for (let d = 0; d < descEntries.length; d++) {
      const entry = descEntries[d];
      const nextDescIdx = d + 1 < descEntries.length ? descEntries[d + 1].idx : rawLines.length;
      
      let lenVal = 1, qtyVal = 1, uom = "", qtyUom2 = "";
      
      /* First: check if qty is on the SAME line as description: "...ASTM A333 Gr.6 - 37 –º" */
      const inlineQty = entry.desc.match(/[-‚Äì‚Äî]\s*(\d+[\.,]?\d*)\s*(—Ç|–º|m|—à—Ç|pcs|–∫–≥|kg)?\s*$/i);
      if (inlineQty) {
        const num = parseFloat(inlineQty[1].replace(",", "."));
        qtyUom2 = (inlineQty[2] || "").toLowerCase();
        if (qtyUom2 === "—Ç") { lenVal = num; }
        else if (qtyUom2 === "–º" || qtyUom2 === "m") { lenVal = num; qtyVal = 1; }
        else if (qtyUom2 === "—à—Ç" || qtyUom2 === "pcs") { qtyVal = Math.round(num); lenVal = 1; }
        else { lenVal = num; }
      } else {
        /* Check next line for "- 0,1 –º" continuation */
        if (entry.idx + 1 < nextDescIdx) {
          const nxtLine = rawLines[entry.idx + 1].trim();
          const contQty = nxtLine.match(/^[-‚Äì‚Äî]\s*(\d+[\.,]?\d*)\s*(—Ç|–º|m|—à—Ç|pcs|–∫–≥|kg)?\s*$/i);
          if (contQty) {
            const num = parseFloat(contQty[1].replace(",", "."));
            qtyUom2 = (contQty[2] || "").toLowerCase();
            if (qtyUom2 === "—Ç") { lenVal = num; }
            else if (qtyUom2 === "–º" || qtyUom2 === "m") { lenVal = num; qtyVal = 1; }
            else if (qtyUom2 === "—à—Ç" || qtyUom2 === "pcs") { qtyVal = Math.round(num); lenVal = 1; }
            else { lenVal = num; }
          }
        }
        
        /* Original: scan lines between descriptions for UOM + value */
        if (lenVal === 1 && qtyVal === 1) {
          for (let k = entry.idx + 1; k < nextDescIdx; k++) {
            const ln = rawLines[k].trim();
            if (/^(m|–º|meter|meters|ft)$/i.test(ln)) { uom = "m"; continue; }
            if (/^(pcs|—à—Ç|pc|ea)$/i.test(ln)) { uom = "pcs"; continue; }
            if (/^(kg|–∫–≥)$/i.test(ln)) { uom = "kg"; continue; }
            if (/^\d+$/.test(ln) && parseInt(ln) < 500 && !uom) continue;
            const num = parseFloat(ln.replace(",", "."));
            if (!isNaN(num) && num >= 0) {
              if (uom === "m" || uom === "") { lenVal = num || 1; qtyVal = 1; }
              else if (uom === "pcs") { qtyVal = Math.max(1, Math.round(num)); lenVal = 1; }
              break;
            }
          }
        }
      }
      
      /* Handle tonnes: back-calculate length from weight */
      if (qtyUom2 === "—Ç") {
        const prof2 = detectProfile(entry.desc);
        if (prof2) {
          const mk2 = detectMetal(entry.desc);
          const pk2 = PARAMS_MAP[prof2.id];
          const dims2 = extractDims(entry.desc);
          if (dims2) {
            const np2 = {};
            pk2.forEach((k, i) => { np2[k] = dims2[i] !== undefined ? dims2[i] : 0; });
            const area2 = calcArea(prof2.id, np2);
            const wpm2 = area2 > 0 ? (area2 / 1e6) * METALS[mk2].density : 0;
            if (wpm2 > 0) {
              const twKg = lenVal * 1000;
              lenVal = parseFloat((twKg / wpm2).toFixed(3));
              qtyVal = 1;
            }
          }
        }
      }
      
      const item = buildEntry(entry.desc, qtyVal, lenVal);
      if (item) newItems.push(item);
    }

    if (newItems.length > 0) { setHist(prev => [...newItems, ...prev]); setShowImport(false); setImportText(""); setImportError(""); return; }

    /* Strategy 3: Single-line format: "7) –ö—Ä—É–≥ (–ø—Ä—É—Ç–æ–∫) 5–º–º ASTM... - 0,032 —Ç" */
    /* Each line has description + quantity, sometimes qty wraps to next line */
    for (let li = 0; li < rawLines.length; li++) {
      const line = rawLines[li];
      /* Remove leading numbering like "7)" or "7." or "7 " */
      const cleaned = line.replace(/^\d+[\)\.\s]+\s*/, "").trim();
      if (!cleaned) continue;
      
      /* Check if this line has dimensions */
      const dims = extractDims(cleaned);
      if (!dims) continue;
      
      /* Try to find quantity: on same line or next line */
      /* Pattern: "- 0,032 —Ç" or "- 37 –º" or "- 15 —à—Ç" */
      let lenVal = 1, qtyVal = 1, qtyUom = "";
      let fullText = cleaned;
      
      /* Check if next line is a continuation (starts with "-" or is just a number+uom) */
      if (li + 1 < rawLines.length) {
        const nextL = rawLines[li + 1].trim();
        if (/^[-‚Äì‚Äî]\s*\d/.test(nextL) || /^\d+[\.,]?\d*\s*(—Ç|–º|m|—à—Ç|pcs|–∫–≥|kg)\s*$/i.test(nextL)) {
          fullText = cleaned + " " + nextL;
          li++; /* skip next line */
        }
      }
      
      const qtyMatch = fullText.match(/[-‚Äì‚Äî]\s*(\d+[\.,]?\d*)\s*(—Ç|–º|m|—à—Ç|pcs|–∫–≥|kg)?\s*$/i);
      if (qtyMatch) {
        const num = parseFloat(qtyMatch[1].replace(",", "."));
        qtyUom = (qtyMatch[2] || "").toLowerCase();
        if (qtyUom === "—Ç") {
          lenVal = num; qtyVal = 1;
        } else if (qtyUom === "–º" || qtyUom === "m") {
          lenVal = num; qtyVal = 1;
        } else if (qtyUom === "—à—Ç" || qtyUom === "pcs") {
          qtyVal = Math.round(num); lenVal = 1;
        } else if (qtyUom === "–∫–≥" || qtyUom === "kg") {
          lenVal = num / 1000; qtyVal = 1;
        } else {
          lenVal = num; qtyVal = 1;
        }
      }
      
      /* Build the entry */
      const prof = detectProfile(fullText);
      if (!prof) continue;
      const metalKey = detectMetal(fullText);
      const pk = PARAMS_MAP[prof.id];
      const po = {};
      pk.forEach((k, i) => { po[k] = dims[i] !== undefined ? String(dims[i]) : "0"; });
      const np = {};
      pk.forEach(k => { np[k] = parseFloat(po[k]) || 0; });
      const dens3 = METALS[metalKey].density;
      const area = calcArea(prof.id, np);
      const wpm3 = area > 0 ? (area / 1e6) * dens3 : 0;
      
      let tw;
      if (qtyUom === "—Ç" && wpm3 > 0) {
        /* Tonnes given directly */
        tw = lenVal * 1000; /* convert tonnes to kg */
        lenVal = tw / wpm3; /* back-calculate length */
        qtyVal = 1;
      } else {
        tw = wpm3 * lenVal * qtyVal;
      }
      
      if (tw > 0) {
        newItems.push({
          id: Date.now() + Math.random(), prof: prof.name, metal: METALS[metalKey].name, metalKey,
          profileId: prof.id, params: po, pk: [...pk], len: parseFloat(lenVal.toFixed(3)), qty: qtyVal, tw,
          desc: fullText.trim(),
        });
      }
    }

    if (newItems.length > 0) { setHist(prev => [...newItems, ...prev]); setShowImport(false); setImportText(""); setImportError(""); }
    else { setImportError("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –ø–æ–∑–∏—Ü–∏–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç."); }
  };

  /* ---- EXCEL / CSV file handler ---- */
  const handleFile = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setImportStatus("–ß–∏—Ç–∞—é —Ñ–∞–π–ª...");
    setImportError("");
    try {
      const ext = file.name.split(".").pop().toLowerCase();
      if (ext === "csv" || ext === "tsv" || ext === "txt") {
        const text = await file.text();
        setImportStatus("");
        parseImport(text);
        return;
      }
      /* XLSX */
      const XLSX = await import("sheetjs");
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type: "array" });
      let allText = "";
      for (const name of wb.SheetNames) {
        const ws = wb.Sheets[name];
        const csv = XLSX.utils.sheet_to_csv(ws, { FS: ";" });
        allText += csv + "\n";
      }
      setImportStatus("");
      parseImport(allText);
    } catch (err) {
      setImportStatus("");
      setImportError("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: " + err.message);
    }
    if (fileRef.current) fileRef.current.value = "";
  };

  /* ---- PDF handler ---- */
  const handlePDF = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setImportStatus("–ß–∏—Ç–∞—é PDF...");
    setImportError("");
    try {
      const buf = await file.arrayBuffer();
      const bytes = new Uint8Array(buf);
      let binary = "";
      const chunk = 8192;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
      }
      const base64 = btoa(binary);
      
      setImportStatus("AI —Ä–∞—Å–ø–æ–∑–Ω–∞—ë—Ç —Ç–∞–±–ª–∏—Ü—É...");
      const resp = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 4000,
          messages: [{
            role: "user",
            content: [
              { type: "document", source: { type: "base64", media_type: "application/pdf", data: base64 } },
              { type: "text", text: `Extract all metal products/pipes from this document. For each item that has dimensions (like DxT or diameter x wall thickness), output one line in format:
ProfileType;Metal;Dim1;Dim2;Length;Qty
Where ProfileType is one of: –¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è, –¢—Ä—É–±–∞ –ø—Ä–æ—Ñ–∏–ª—å–Ω–∞—è, –ö—Ä—É–≥, –ê—Ä–º–∞—Ç—É—Ä–∞, –ö–≤–∞–¥—Ä–∞—Ç, –®–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫, –õ–∏—Å—Ç, –£–≥–æ–ª–æ–∫, –®–≤–µ–ª–ª–µ—Ä, –î–≤—É—Ç–∞–≤—Ä
Metal: –°—Ç–∞–ª—å (default), –ù–µ—Ä–∂–∞–≤–µ–π–∫–∞, –ê–ª—é–º–∏–Ω–∏–π, etc.
Dim1, Dim2: dimensions in mm (diameter, wall thickness etc.)
Length: length in meters (use 1 if unit is pcs)
Qty: quantity (default 1)

Output ONLY the CSV lines, nothing else. No headers, no explanations.
Example: –¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;168.3;14.27;276.693;1` }
            ]
          }]
        })
      });
      if (!resp.ok) {
        const errText = await resp.text().catch(() => "");
        setImportStatus("");
        setImportError(`PDF API (${resp.status}): ${errText.slice(0, 300)}`);
        return;
      }
      const rawT = await resp.text();
      let data;
      try { data = JSON.parse(rawT); } catch (pe) {
        setImportStatus("");
        setImportError("PDF –æ—Ç–≤–µ—Ç –Ω–µ JSON: " + rawT.slice(0, 300));
        return;
      }
      if (data.error) {
        setImportStatus("");
        setImportError("API: " + (data.error.message || JSON.stringify(data.error)));
        return;
      }
      const text = data.content?.map(c => c.text || "").join("\n") || "";
      setImportStatus("");
      if (text.trim()) { parseImport(text); }
      else { setImportError("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ PDF"); }
    } catch (err) {
      setImportStatus("");
      setImportError("–û—à–∏–±–∫–∞ PDF: " + err.message);
    }
    if (fileRef.current) fileRef.current.value = "";
  };

  /* ---- Compress image via canvas ---- */
  const compressImage = (file, maxDim = 1200, quality = 0.8) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          let w = img.width, h = img.height;
          if (w > maxDim || h > maxDim) {
            const ratio = Math.min(maxDim / w, maxDim / h);
            w = Math.round(w * ratio);
            h = Math.round(h * ratio);
          }
          const canvas = document.createElement("canvas");
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, w, h);
          const dataUrl = canvas.toDataURL("image/jpeg", quality);
          const base64 = dataUrl.split(",")[1];
          resolve({ base64, mediaType: "image/jpeg" });
        };
        img.onerror = () => reject(new Error("Image decode failed"));
        img.src = reader.result;
      };
      reader.onerror = () => reject(new Error("FileReader failed"));
      reader.readAsDataURL(file);
    });
  };

  /* ---- Process image (shared by file pick & paste) ---- */
  const processImage = async (file) => {
    setImportStatus("–°–∂–∏–º–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...");
    setImportError("");
    try {
      const { base64, mediaType } = await compressImage(file, 800, 0.6);
      const sizeKB = Math.round(base64.length * 0.75 / 1024);
      setImportStatus(`AI —Ä–∞—Å–ø–æ–∑–Ω–∞—ë—Ç (${sizeKB} –ö–ë)...`);
      
      const body = {
        model: "claude-sonnet-4-20250514",
        max_tokens: 4000,
        messages: [{
          role: "user",
          content: [
            { type: "image", source: { type: "base64", media_type: mediaType, data: base64 } },
            { type: "text", text: `Extract all metal pipe items from this image table. For each item with dimensions in parentheses like (168.3x14.27), output one CSV line:
–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;Diameter;WallThickness;Length;Qty
If UOM=m: Length=Qty value, Qty=1. If UOM=pcs: Length=1, Qty=number.
Output ONLY CSV lines, no headers, no markdown.` }
          ]
        }]
      };

      let resp;
      try {
        resp = await fetch("https://api.anthropic.com/v1/messages", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
      } catch (fetchErr) {
        setImportStatus("");
        setImportError("Fetch: " + fetchErr.message + " (" + fetchErr.name + "). –†–∞–∑–º–µ—Ä: " + sizeKB + " –ö–ë");
        return;
      }
      
      if (!resp.ok) {
        const errText = await resp.text().catch(() => "–Ω–µ—Ç —Ç–µ–ª–∞");
        setImportStatus("");
        setImportError(`HTTP ${resp.status}: ${errText.slice(0, 300)}`);
        return;
      }
      
      let rawText;
      try { rawText = await resp.text(); } catch (readErr) {
        setImportStatus("");
        setImportError("–ß—Ç–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞: " + readErr.message);
        return;
      }

      let data;
      try { data = JSON.parse(rawText); } catch (pe) {
        setImportStatus("");
        setImportError("–ù–µ JSON (" + rawText.length + "): " + rawText.slice(0, 200));
        return;
      }
      
      if (data.error) {
        setImportStatus("");
        setImportError("API: " + (data.error.message || JSON.stringify(data.error)));
        return;
      }
      
      const text = data.content?.map(c => c.text || "").join("\n") || "";
      setImportStatus("");
      if (text.trim()) { parseImport(text); }
      else { setImportError("AI –Ω–µ –Ω–∞—à—ë–ª –ø–æ–∑–∏—Ü–∏–π. –û—Ç–≤–µ—Ç: " + JSON.stringify(data).slice(0, 200)); }
    } catch (err) {
      setImportStatus("");
      setImportError(err.name + ": " + err.message);
    }
  };

  /* ---- Photo from file input ---- */
  const handlePhoto = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    await processImage(file);
    if (e.target) e.target.value = "";
  };

  /* ---- Paste handler (Ctrl+V / clipboard) ---- */
  const handlePaste = useCallback(async (e) => {
    if (!showImport) return;
    const items = e.clipboardData?.items;
    if (!items) return;
    for (const item of items) {
      if (item.type.startsWith("image/")) {
        e.preventDefault();
        const file = item.getAsFile();
        if (file) {
          setImportTab("photo");
          await processImage(file);
        }
        return;
      }
    }
  }, [showImport]);

  useEffect(() => {
    document.addEventListener("paste", handlePaste);
    return () => document.removeEventListener("paste", handlePaste);
  }, [handlePaste]);

  /* ---- DOCX handler ‚Äî always use AI for best results ---- */
  const handleDocx = async (file) => {
    setImportStatus("AI –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç...");
    setImportError("");
    try {
      const buf = await file.arrayBuffer();
      const bytes = new Uint8Array(buf);
      /* Convert to base64 in chunks to avoid call stack overflow */
      let binary = "";
      const chunk = 8192;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
      }
      const base64 = btoa(binary);
      
      const resp = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 8000,
          messages: [{
            role: "user",
            content: [
              { type: "document", source: { type: "base64", media_type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document", data: base64 } },
              { type: "text", text: `This is a Request for Quotation for metal products. Extract ALL items that have pipe/tube dimensions (DxT format like 168.3x14.27) from the tables in this document.

For each item with dimensions, output one line in this exact CSV format:
–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;Diameter_mm;WallThickness_mm;Length_m;Qty

Rules:
- If UOM is "m" (meters): set Length = the Qty value from the table, set Qty = 1
- If UOM is "pcs": set Length = 1, set Qty = the quantity number from the table  
- For nipples with length like L=75mm or L=150mm: use Length = 0.075 or 0.15 (convert mm to meters), Qty = the pcs quantity
- For elbows, tees, reducers (pcs items with dimensions): set Length = 1, Qty = the pcs quantity
- Extract dimensions from parentheses like (26.7x3.91) where first = diameter mm, second = wall thickness mm
- For reducers with format (457.2x39.67-355.6x31.75): use the LARGER diameter pair (457.2x39.67)
- Skip items that have NO dimensions in parentheses (flanges without DxT, gaskets, bolts, spectacle blinds)
- Use –°—Ç–∞–ª—å as metal for all

Output ONLY the semicolon-separated CSV lines. No headers, no markdown, no backticks, no explanations.
Example output:
–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;26.7;3.91;2.184;1
–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;168.3;14.27;276.693;1
–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;26.7;5.56;0.075;56
–¢—Ä—É–±–∞ –∫—Ä—É–≥–ª–∞—è;–°—Ç–∞–ª—å;33.4;6.35;1;7` }
            ]
          }]
        })
      });
      if (!resp.ok) {
        const errText = await resp.text().catch(() => "");
        setImportStatus("");
        setImportError(`DOCX API (${resp.status}): ${errText.slice(0, 300)}`);
        return;
      }
      const rawD = await resp.text();
      let data;
      try { data = JSON.parse(rawD); } catch (pe) {
        setImportStatus("");
        setImportError("DOCX –æ—Ç–≤–µ—Ç –Ω–µ JSON: " + rawD.slice(0, 300));
        return;
      }
      if (data.error) {
        setImportStatus("");
        setImportError("API –æ—à–∏–±–∫–∞: " + (data.error.message || JSON.stringify(data.error)));
        return;
      }
      const aiText = data.content?.map(c => c.text || "").join("\n") || "";
      setImportStatus("");
      if (aiText.trim()) { 
        parseImport(aiText); 
      } else { 
        setImportError("AI –Ω–µ –≤–µ—Ä–Ω—É–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–∞–∫ PDF."); 
      }
    } catch (err) {
      setImportStatus("");
      setImportError("–û—à–∏–±–∫–∞: " + err.message);
    }
  };

  const inp = { width: "100%", padding: mob ? "12px" : "10px 12px", background: "rgba(255,255,255,0.06)", border: "1px solid rgba(255,255,255,0.12)", borderRadius: 8, color: "#fff", fontSize: 16, fontFamily: "'JetBrains Mono',monospace", outline: "none", WebkitAppearance: "none", appearance: "none", MozAppearance: "textfield" };
  const lbl = { fontSize: 11, color: "rgba(255,255,255,0.45)", display: "block", marginBottom: 4, fontFamily: "'Nunito',sans-serif", fontWeight: 600 };
  const btn = (active, bg, clr) => ({ padding: mob ? "12px 16px" : "10px 14px", background: active ? bg : "rgba(255,255,255,0.04)", border: "none", borderRadius: 8, color: active ? clr : "rgba(255,255,255,0.15)", fontSize: 14, fontWeight: 700, cursor: active ? "pointer" : "default", fontFamily: "'Nunito',sans-serif", WebkitAppearance: "none" });

  return (
    <div style={{ minHeight: "100vh", background: "linear-gradient(160deg,#0b1a0f,#122118 40%,#1a2f22)", fontFamily: "'Segoe UI',-apple-system,sans-serif", color: "#e8f0ea", WebkitTextSizeAdjust: "100%" }}>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Nunito:wght@400;600;700;800&display=swap');
        *{box-sizing:border-box;margin:0;padding:0}
        input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0;display:none}
        input[type="number"]{-moz-appearance:textfield;-webkit-appearance:none;appearance:none}
        input:focus,select:focus,textarea:focus{border-color:#52b788!important;outline:none}
        select{-webkit-appearance:none;appearance:none}
      `}</style>

      {/* Header */}
      <div style={{ background: "linear-gradient(135deg,#2d6a4f,#1b4332)", padding: mob ? "10px 14px" : "12px 18px", display: "flex", alignItems: "center", gap: 10 }}>
        <div style={{ width: 32, height: 32, borderRadius: 8, background: "rgba(255,255,255,0.12)", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 15, flexShrink: 0 }}>‚öôÔ∏è</div>
        <h1 style={{ fontFamily: "'Nunito',sans-serif", fontSize: mob ? 15 : 18, fontWeight: 800, color: "#fff" }}>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –º–µ—Ç–∞–ª–ª–æ–ø—Ä–æ–∫–∞—Ç–∞</h1>
      </div>

      {/* Mobile: horizontal profile scroll */}
      {mob && (
        <div style={{ position: "relative", padding: "8px 0 0" }}>
          <div style={{ overflowX: "auto", display: "flex", gap: 6, padding: "0 10px", WebkitOverflowScrolling: "touch" }}>
            {PROFILES.map(p => (
              <button key={p.id} onClick={() => setPid(p.id)} style={{
                flexShrink: 0, width: 56, padding: "5px 2px 3px",
                background: pid === p.id ? "linear-gradient(135deg,#2d6a4f,#40916c)" : "rgba(255,255,255,0.03)",
                border: pid === p.id ? "1.5px solid rgba(82,183,136,0.6)" : "1.5px solid rgba(255,255,255,0.06)",
                borderRadius: 10, cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 1, WebkitAppearance: "none",
              }}>
                <ProfileIcon id={p.id} active={pid === p.id} />
                <span style={{ fontSize: 7, color: pid === p.id ? "#fff" : "rgba(255,255,255,0.35)", fontFamily: "'Nunito',sans-serif", fontWeight: 700, textAlign: "center", lineHeight: 1.1 }}>{p.short}</span>
              </button>
            ))}
            {/* Spacer so last icon isn't hidden by fade */}
            <div style={{ flexShrink: 0, width: 24 }} />
          </div>
          {/* Right fade indicator ‚Üí shows there are more icons */}
          <div style={{
            position: "absolute", top: 0, right: 0, bottom: 0, width: 40,
            background: "linear-gradient(to right, transparent, #111f16)",
            pointerEvents: "none", display: "flex", alignItems: "center", justifyContent: "flex-end", paddingRight: 6,
          }}>
            <span style={{ color: "rgba(82,183,136,0.6)", fontSize: 14 }}>‚Ä∫</span>
          </div>
        </div>
      )}

      <div style={{ maxWidth: 1060, margin: "0 auto", padding: mob ? "8px" : "12px 10px", display: "flex", gap: 10, flexDirection: mob ? "column" : "row" }}>
        {/* Desktop: vertical icon strip */}
        {!mob && (
          <div style={{ display: "flex", flexDirection: "column", gap: 4, flexShrink: 0 }}>
            {PROFILES.map(p => (
              <button key={p.id} onClick={() => setPid(p.id)} title={p.name} style={{
                width: 58, minHeight: 52, flexShrink: 0, padding: "4px 2px 2px",
                background: pid === p.id ? "linear-gradient(135deg,#2d6a4f,#40916c)" : "rgba(255,255,255,0.03)",
                border: pid === p.id ? "1.5px solid rgba(82,183,136,0.6)" : "1.5px solid rgba(255,255,255,0.06)",
                borderRadius: 10, cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: 2,
              }}>
                <ProfileIcon id={p.id} active={pid === p.id} />
                <span style={{ fontSize: 7.5, color: pid === p.id ? "#fff" : "rgba(255,255,255,0.35)", fontFamily: "'Nunito',sans-serif", fontWeight: 700, textAlign: "center", lineHeight: 1.1 }}>{p.short}</span>
              </button>
            ))}
          </div>
        )}

        {/* Main content */}
        <div style={{ flex: 1, display: "flex", flexDirection: "column", gap: 10, minWidth: 0 }}>
          <div style={{ background: "rgba(255,255,255,0.03)", borderRadius: 12, border: "1px solid rgba(255,255,255,0.06)", padding: mob ? "12px" : "14px 16px" }}>

            {/* Metal ‚Äî searchable autocomplete */}
            <div style={{ marginBottom: 12, position: "relative" }}>
              <label style={{ ...lbl, color: "#52b788", textTransform: "uppercase", letterSpacing: "0.08em", fontSize: 10 }}>–ú–ï–¢–ê–õ–õ</label>
              <MetalPicker value={metal} onChange={setMetal} mob={mob} />
            </div>

            {/* Drawing + Fields ‚Äî stacks vertically on mobile */}
            <div style={{ display: "flex", flexDirection: mob ? "column" : "row", gap: mob ? 10 : 14, alignItems: mob ? "center" : "flex-start" }}>
              <div style={{ display: "flex", flexDirection: "column", alignItems: "center", flexShrink: 0 }}>
                <TechDrawing profileId={pid} size={mob ? 130 : 160} />
                <span style={{ fontSize: 12, fontWeight: 700, color: "#52b788", fontFamily: "'Nunito',sans-serif", textAlign: "center" }}>{prof?.name}</span>
              </div>

              <div style={{ display: "flex", flexDirection: "column", gap: 10, width: "100%" }}>
                {/* Dimension inputs ‚Äî always 2 cols, 1 col if single param */}
                <div style={{ display: "grid", gridTemplateColumns: pKeys.length === 1 ? "1fr" : "1fr 1fr", gap: 8 }}>
                  {pKeys.map((k, i) => { const d = PARAM_DEFS[k]; const ph = syncTargets.has(k) ? (params[Object.entries(syncPairs).find(([,b]) => b === k)?.[0]] || "= " + (k === "shelfB" ? "a" : "A")) : "0"; const symO = (k === "shelfWidth" && (pid === "channel" || pid === "beam")) ? "b" : d.sym; const lblO = (k === "shelfWidth" && (pid === "channel" || pid === "beam")) ? "–ü–æ–ª–∫–∞" : d.label; return (
                    <div key={k}>
                      <label style={lbl}><span style={{ color: "#52b788", fontWeight: 700, marginRight: 2 }}>{symO}</span> {lblO}, {d.unit}</label>
                      <input ref={i === 0 ? fr : null} type="text" inputMode="decimal" pattern="[0-9.,]*" min="0" step="any" style={inp} value={params[k] || ""} onChange={e => setP(k, e.target.value)} placeholder={ph} />
                    </div>
                  ); })}
                </div>

                {/* Wpm */}
                {wpm > 0 && (
                  <div style={{ background: "rgba(45,106,79,0.15)", borderRadius: 8, padding: "7px 12px", border: "1px solid rgba(82,183,136,0.2)", display: "flex", alignItems: "center", gap: 6, flexWrap: "wrap" }}>
                    <span style={{ fontSize: 12, color: "rgba(255,255,255,0.4)" }}>1 –ø.–º.:</span>
                    <span style={{ fontSize: 17, fontWeight: 700, color: "#52b788", fontFamily: "'JetBrains Mono',monospace" }}>{fmt(wpm)}</span>
                    <span style={{ fontSize: 12, color: "rgba(255,255,255,0.3)" }}>–∫–≥/–º</span>
                  </div>
                )}

                {/* Length + Weight ‚Äî 2 columns */}
                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 8 }}>
                  <div>
                    <label style={lbl}>–î–ª–∏–Ω–∞, –º</label>
                    <input type="text" inputMode="decimal" pattern="[0-9.,]*" min="0" step="any" style={inp} value={length} onChange={e => hLen(e.target.value)} placeholder="0" />
                  </div>
                  <div>
                    <label style={lbl}>–í–µ—Å, –∫–≥</label>
                    <input type="text" inputMode="decimal" pattern="[0-9.,]*" min="0" step="any" style={inp} value={weight} onChange={e => hWt(e.target.value)} placeholder="0" />
                  </div>
                </div>

                {/* Qty + buttons ‚Äî flex wrap for mobile */}
                <div style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
                  <div style={{ width: 70, flexShrink: 0 }}>
                    <label style={lbl}>–®—Ç</label>
                    <input type="text" inputMode="numeric" pattern="[0-9]*" min="1" step="1" style={inp} value={qty} onChange={e => setQty(e.target.value)} />
                  </div>
                  <button onClick={addH} disabled={!canAdd} style={{ ...btn(canAdd, "linear-gradient(135deg,#e8a838,#d4882a)", "#1a1a1a"), flex: 1, minWidth: 90 }}>+ –î–æ–±–∞–≤–∏—Ç—å</button>
                  {/* Import button hidden ‚Äî TODO: fix AI import errors */}
                </div>

                {/* Qty total */}
                {parseFloat(weight) > 0 && (parseInt(qty) || 1) > 1 && (
                  <div style={{ background: "rgba(45,106,79,0.15)", borderRadius: 8, padding: "7px 12px", border: "1px solid rgba(82,183,136,0.15)", display: "flex", alignItems: "center", gap: 6, flexWrap: "wrap" }}>
                    <span style={{ fontSize: 12, color: "rgba(255,255,255,0.35)" }}>{qty} √ó {fmt(parseFloat(weight))} =</span>
                    <span style={{ fontSize: 17, fontWeight: 700, color: "#e8a838", fontFamily: "'JetBrains Mono',monospace" }}>{fmt(parseFloat(weight) * (parseInt(qty) || 1))} –∫–≥</span>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* History */}
          {hist.length > 0 && (
            <div style={{ background: "rgba(255,255,255,0.03)", borderRadius: 12, border: "1px solid rgba(255,255,255,0.06)", padding: "12px" }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 8, flexWrap: "wrap", gap: 6 }}>
                <span style={{ fontSize: 10, fontWeight: 700, textTransform: "uppercase", letterSpacing: "0.1em", color: "#52b788", fontFamily: "'Nunito',sans-serif" }}>–ü–æ–∑–∏—Ü–∏–∏ ({hist.length})</span>
                <div style={{ display: "flex", gap: 5 }}>
                  <button onClick={copyTSV} style={{ background: copied ? "rgba(82,183,136,0.2)" : "rgba(255,255,255,0.04)", border: "1px solid " + (copied ? "rgba(82,183,136,0.4)" : "rgba(255,255,255,0.07)"), borderRadius: 5, padding: "4px 10px", color: copied ? "#52b788" : "rgba(255,255,255,0.35)", fontSize: 10, cursor: "pointer", fontFamily: "'Nunito',sans-serif", fontWeight: 600 }}>{copied ? "‚úì" : "üìã Excel"}</button>
                  <button onClick={() => setHist([])} style={{ background: "rgba(255,80,80,0.07)", border: "1px solid rgba(255,80,80,0.12)", borderRadius: 5, padding: "4px 10px", color: "#ff8080", fontSize: 10, cursor: "pointer", fontFamily: "'Nunito',sans-serif", fontWeight: 600 }}>–û—á–∏—Å—Ç–∏—Ç—å</button>
                </div>
              </div>

              {mob ? (
                /* Mobile: cards */
                <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
                  {hist.map((e, idx) => (
                    <div key={e.id} onClick={() => loadH(e)} style={{ background: "rgba(255,255,255,0.02)", borderRadius: 8, padding: "10px 12px", border: "1px solid rgba(255,255,255,0.05)", cursor: "pointer", position: "relative" }}>
                      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "flex-start" }}>
                        <div>
                          <span style={{ fontSize: 10, color: "rgba(255,255,255,0.2)", fontFamily: "'JetBrains Mono',monospace", marginRight: 6 }}>{idx + 1}.</span>
                          <span style={{ fontWeight: 700, fontSize: 13 }}>{e.prof}</span>
                          <span style={{ fontSize: 11, color: "rgba(255,255,255,0.35)", marginLeft: 6 }}>{e.metal}</span>
                        </div>
                        <button onClick={ev => { ev.stopPropagation(); rmH(e.id); }} style={{ background: "none", border: "none", color: "rgba(255,255,255,0.2)", cursor: "pointer", fontSize: 18, padding: 4, marginTop: -4, marginRight: -4 }}>√ó</button>
                      </div>
                      <div style={{ fontSize: 11, color: "rgba(255,255,255,0.4)", marginTop: 2 }}>
                        {e.pk.map(k => e.params[k]).join("√ó")} –º–º ¬∑ {e.len} –º ¬∑ {e.qty} —à—Ç
                      </div>
                      {e.desc && <div style={{ fontSize: 10, color: "rgba(255,255,255,0.25)", marginTop: 1, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{e.desc}</div>}
                      <div style={{ fontSize: 16, fontWeight: 700, color: "#52b788", fontFamily: "'JetBrains Mono',monospace", marginTop: 4 }}>{fmt(e.tw)} –∫–≥</div>
                    </div>
                  ))}
                  <div style={{ padding: "10px 0 0", borderTop: "2px solid rgba(82,183,136,0.2)", display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                    <span style={{ fontWeight: 700, fontSize: 14, fontFamily: "'Nunito',sans-serif" }}>–ò–¢–û–ì–û</span>
                    <div style={{ textAlign: "right" }}>
                      <div style={{ fontSize: 18, fontWeight: 700, color: "#e8a838", fontFamily: "'JetBrains Mono',monospace" }}>{fmt(totW)} –∫–≥</div>
                      {totW >= 1000 && <div style={{ fontSize: 12, color: "rgba(232,168,56,0.5)" }}>{fmt(totW / 1000)} —Ç</div>}
                    </div>
                  </div>
                </div>
              ) : (
                /* Desktop: table */
                <div style={{ overflowX: "auto" }}>
                  <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 12 }}>
                    <thead><tr style={{ borderBottom: "1px solid rgba(255,255,255,0.06)" }}>
                      {["#","–ü—Ä–æ—Ñ–∏–ª—å","–ú–µ—Ç–∞–ª–ª","–†–∞–∑–º–µ—Ä—ã","–î–ª–∏–Ω–∞","–®—Ç","–í–µ—Å, –∫–≥",""].map((h,i) => <th key={i} style={{ padding: "4px 6px", textAlign: "left", color: "rgba(255,255,255,0.28)", fontWeight: 600, fontFamily: "'Nunito',sans-serif", fontSize: 10 }}>{h}</th>)}
                    </tr></thead>
                    <tbody>{hist.map((e, idx) => {
                      const isEd = editId === e.id;
                      const editInp = { background: "rgba(255,255,255,0.1)", border: "1px solid rgba(82,183,136,0.4)", borderRadius: 4, color: "#fff", padding: "3px 6px", fontFamily: "'JetBrains Mono',monospace", fontSize: 12, width: 70, outline: "none" };
                      return (
                      <tr key={e.id} onClick={() => { if (!isEd) loadH(e); }} style={{ borderBottom: "1px solid rgba(255,255,255,0.03)", cursor: "pointer", background: isEd ? "rgba(82,183,136,0.06)" : "transparent" }}
                        onMouseEnter={ev => { if (!isEd) ev.currentTarget.style.background = "rgba(82,183,136,0.08)"; }}
                        onMouseLeave={ev => { if (!isEd) ev.currentTarget.style.background = "transparent"; }}>
                        <td style={{ padding: "5px 6px", color: "rgba(255,255,255,0.2)", fontSize: 10, fontFamily: "'JetBrains Mono',monospace" }}>{idx + 1}</td>
                        <td style={{ padding: "5px 6px", fontWeight: 600, fontSize: 11 }}>{e.prof}</td>
                        <td style={{ padding: "5px 6px", color: "rgba(255,255,255,0.45)", fontSize: 11 }}>{e.metal}</td>
                        <td style={{ padding: "5px 6px", fontFamily: "'JetBrains Mono',monospace", fontSize: 11, color: "rgba(255,255,255,0.35)" }}>{e.pk.map(k => e.params[k]).join("√ó")}</td>
                        <td style={{ padding: "3px 6px" }}>{isEd
                          ? <input type="text" inputMode="decimal" value={editLen} onChange={ev => setEditLen(ev.target.value)} onKeyDown={ev => { if (ev.key === "Enter") saveEdit(e); if (ev.key === "Escape") setEditId(null); }} autoFocus style={editInp} />
                          : <span onDoubleClick={ev => startEdit(e, ev)} style={{ fontFamily: "'JetBrains Mono',monospace", cursor: "text" }}>{e.len}</span>
                        }</td>
                        <td style={{ padding: "3px 6px" }}>{isEd
                          ? <input type="text" inputMode="numeric" value={editQty} onChange={ev => setEditQty(ev.target.value)} onKeyDown={ev => { if (ev.key === "Enter") saveEdit(e); if (ev.key === "Escape") setEditId(null); }} style={{ ...editInp, width: 44 }} />
                          : <span onDoubleClick={ev => startEdit(e, ev)} style={{ fontFamily: "'JetBrains Mono',monospace", cursor: "text" }}>{e.qty}</span>
                        }</td>
                        <td style={{ padding: "5px 6px", fontFamily: "'JetBrains Mono',monospace", color: "#52b788", fontWeight: 600 }}>{fmt(isEd ? (() => { const np2 = {}; e.pk.forEach(k => { np2[k] = parseFloat(e.params[k]) || 0; }); const a = calcArea(e.profileId, np2); const w2 = a > 0 ? (a / 1e6) * METALS[e.metalKey].density : 0; return w2 * (parseFloat(editLen) || 0) * (parseInt(editQty) || 0); })() : e.tw)}</td>
                        <td style={{ padding: "3px 6px", whiteSpace: "nowrap" }}>{isEd
                          ? <><button onClick={ev => { ev.stopPropagation(); saveEdit(e); }} style={{ background: "none", border: "none", color: "#52b788", cursor: "pointer", fontSize: 14, padding: "0 4px" }}>‚úì</button><button onClick={ev => { ev.stopPropagation(); setEditId(null); }} style={{ background: "none", border: "none", color: "rgba(255,255,255,0.2)", cursor: "pointer", fontSize: 14, padding: "0 4px" }}>‚úï</button></>
                          : <button onClick={ev => { ev.stopPropagation(); rmH(e.id); }} style={{ background: "none", border: "none", color: "rgba(255,255,255,0.15)", cursor: "pointer", fontSize: 14 }}>√ó</button>
                        }</td>
                      </tr>);
                    })}</tbody>
                    <tfoot>
                      <tr style={{ borderTop: "2px solid rgba(82,183,136,0.2)" }}>
                        <td colSpan={6} style={{ padding: "8px 6px", fontWeight: 700, fontSize: 13, fontFamily: "'Nunito',sans-serif" }}>–ò–¢–û–ì–û</td>
                        <td style={{ padding: "8px 6px", fontFamily: "'JetBrains Mono',monospace", color: "#e8a838", fontWeight: 700, fontSize: 15 }}>{fmt(totW)} –∫–≥</td><td></td>
                      </tr>
                      {totW >= 1000 && <tr><td colSpan={6}></td><td style={{ padding: "1px 6px 6px", fontFamily: "'JetBrains Mono',monospace", color: "rgba(232,168,56,0.5)", fontSize: 12 }}>{fmt(totW / 1000)} —Ç</td><td></td></tr>}
                    </tfoot>
                  </table>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {/* Import Modal */}
      {showImport && (
        <div style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.75)", display: "flex", alignItems: mob ? "flex-end" : "center", justifyContent: "center", zIndex: 1000 }} onClick={() => { setShowImport(false); setImportError(""); setImportStatus(""); }}>
          <div style={{ background: "linear-gradient(160deg,#122118,#1a2f22)", borderRadius: mob ? "16px 16px 0 0" : 16, border: "1px solid rgba(82,183,136,0.3)", padding: mob ? "16px 14px 24px" : "24px", maxWidth: 560, width: "100%", maxHeight: mob ? "80vh" : "85vh", overflow: "auto" }} onClick={e => e.stopPropagation()}>
            
            {/* Header */}
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 12 }}>
              <h2 style={{ fontFamily: "'Nunito',sans-serif", fontSize: 16, fontWeight: 800, color: "#fff" }}>üì• –ò–º–ø–æ—Ä—Ç –∑–∞—è–≤–∫–∏</h2>
              <button onClick={() => { setShowImport(false); setImportError(""); setImportStatus(""); }} style={{ background: "none", border: "none", color: "rgba(255,255,255,0.3)", cursor: "pointer", fontSize: 22, padding: 4 }}>√ó</button>
            </div>

            {/* Tabs */}
            <div style={{ display: "flex", gap: 4, marginBottom: 14 }}>
              {[
                { id: "text", label: "üìù –¢–µ–∫—Å—Ç", icon: "" },
                { id: "file", label: "üìÅ –§–∞–π–ª", icon: "" },
                { id: "photo", label: "üì∑ –§–æ—Ç–æ", icon: "" },
              ].map(t => (
                <button key={t.id} onClick={() => { setImportTab(t.id); setImportError(""); setImportStatus(""); }} style={{
                  flex: 1, padding: "9px 8px", borderRadius: 8, cursor: "pointer", fontSize: 13, fontWeight: 700,
                  fontFamily: "'Nunito',sans-serif", border: "none",
                  background: importTab === t.id ? "rgba(82,183,136,0.2)" : "rgba(255,255,255,0.04)",
                  color: importTab === t.id ? "#52b788" : "rgba(255,255,255,0.35)",
                }}>
                  {t.label}
                </button>
              ))}
            </div>

            {/* Loading overlay */}
            {importStatus && (
              <div style={{ background: "rgba(45,106,79,0.2)", borderRadius: 10, padding: "16px", marginBottom: 12, textAlign: "center", border: "1px solid rgba(82,183,136,0.2)" }}>
                <div style={{ fontSize: 20, marginBottom: 6 }}>‚è≥</div>
                <div style={{ fontSize: 13, color: "#52b788", fontWeight: 600 }}>{importStatus}</div>
              </div>
            )}

            {/* Error */}
            {importError && (
              <div style={{ background: "rgba(255,80,80,0.1)", borderRadius: 8, padding: "10px 14px", marginBottom: 12, border: "1px solid rgba(255,80,80,0.2)", fontSize: 12, color: "#ff8080" }}>
                {importError}
              </div>
            )}

            {/* Tab: Text */}
            {importTab === "text" && !importStatus && (
              <div>
                <div style={{ fontSize: 11, color: "rgba(255,255,255,0.4)", marginBottom: 8, lineHeight: 1.5 }}>
                  –í—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–∑ Word, PDF –∏–ª–∏ CSV. –ü–∞—Ä—Å–µ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–π–¥—ë—Ç —Ä–∞–∑–º–µ—Ä—ã –≤ —Å–∫–æ–±–∫–∞—Ö, –Ω–∞–ø—Ä–∏–º–µ—Ä <span style={{ color: "#52b788" }}>(168.3x14.27)</span>
                </div>
                <textarea value={importText} onChange={e => setImportText(e.target.value)} placeholder={importExample}
                  style={{ width: "100%", height: mob ? 120 : 150, padding: 12, background: "rgba(255,255,255,0.06)", border: "1px solid rgba(255,255,255,0.12)", borderRadius: 8, color: "#fff", fontSize: 13, fontFamily: "'JetBrains Mono',monospace", outline: "none", resize: "vertical", lineHeight: 1.6 }} />
                <div style={{ display: "flex", gap: 8, marginTop: 10 }}>
                  <button onClick={() => setImportText(importExample)} style={{ padding: "10px 16px", background: "rgba(255,255,255,0.05)", border: "1px solid rgba(255,255,255,0.1)", borderRadius: 8, color: "rgba(255,255,255,0.5)", fontSize: 12, fontWeight: 600, cursor: "pointer", fontFamily: "'Nunito',sans-serif" }}>–ü—Ä–∏–º–µ—Ä</button>
                  <button onClick={() => parseImport(importText)} disabled={!importText.trim()} style={{ flex: 1, padding: "10px 20px", background: importText.trim() ? "linear-gradient(135deg,#e8a838,#d4882a)" : "rgba(255,255,255,0.04)", border: "none", borderRadius: 8, color: importText.trim() ? "#1a1a1a" : "rgba(255,255,255,0.15)", fontSize: 14, fontWeight: 700, cursor: importText.trim() ? "pointer" : "default", fontFamily: "'Nunito',sans-serif" }}>–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
              </div>
            )}

            {/* Tab: File (Excel / CSV / PDF) */}
            {importTab === "file" && !importStatus && (
              <div>
                <div style={{ fontSize: 12, color: "rgba(255,255,255,0.4)", marginBottom: 12, lineHeight: 1.5 }}>
                  –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª —Å –∑–∞—è–≤–∫–æ–π. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è:
                  <span style={{ color: "#52b788" }}> .xlsx, .csv, .tsv, .pdf</span>
                </div>
                <input ref={fileRef} type="file" accept=".xlsx,.xls,.csv,.tsv,.txt,.pdf,.doc,.docx" style={{ display: "none" }}
                  onChange={(e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;
                    const ext = file.name.split(".").pop().toLowerCase();
                    if (ext === "pdf") handlePDF(e);
                    else if (ext === "doc" || ext === "docx") handleDocx(file);
                    else handleFile(e);
                    if (fileRef.current) fileRef.current.value = "";
                  }} />
                <button onClick={() => fileRef.current?.click()} style={{
                  width: "100%", padding: "28px 20px", borderRadius: 12, cursor: "pointer",
                  background: "rgba(255,255,255,0.03)", border: "2px dashed rgba(82,183,136,0.3)",
                  display: "flex", flexDirection: "column", alignItems: "center", gap: 8,
                }}>
                  <span style={{ fontSize: 32 }}>üìÅ</span>
                  <span style={{ fontSize: 14, fontWeight: 700, color: "#52b788", fontFamily: "'Nunito',sans-serif" }}>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª</span>
                  <span style={{ fontSize: 11, color: "rgba(255,255,255,0.3)" }}>Excel, CSV, Word –∏–ª–∏ PDF</span>
                </button>
                <div style={{ fontSize: 11, color: "rgba(255,255,255,0.25)", marginTop: 10, lineHeight: 1.5 }}>
                  PDF –∏ Word –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ AI ‚Äî –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 10-15 —Å–µ–∫—É–Ω–¥
                </div>
              </div>
            )}

            {/* Tab: Photo */}
            {importTab === "photo" && !importStatus && (
              <div>
                {mob && (
                  <div style={{ background: "rgba(232,168,56,0.1)", border: "1px solid rgba(232,168,56,0.3)", borderRadius: 10, padding: "12px 14px", marginBottom: 12 }}>
                    <div style={{ fontSize: 13, fontWeight: 700, color: "#e8a838", marginBottom: 4 }}>üì± –ù–∞ –º–æ–±–∏–ª—å–Ω–æ–º AI-—Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ</div>
                    <div style={{ fontSize: 11, color: "rgba(255,255,255,0.5)", lineHeight: 1.5 }}>
                      –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ/—Å–∫—Ä–∏–Ω—à–æ—Ç –º–Ω–µ –≤ —á–∞—Ç ‚Äî —è —Ä–∞—Å–ø–æ–∑–Ω–∞—é –∏ –ø–æ–¥–≥–æ—Ç–æ–≤–ª—é —Ç–µ–∫—Å—Ç –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ —á–µ—Ä–µ–∑ –≤–∫–ª–∞–¥–∫—É ¬´–¢–µ–∫—Å—Ç¬ª.
                      –ù–∞ –¥–µ—Å–∫—Ç–æ–ø–µ AI-–∑–∞–≥—Ä—É–∑–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞–ø—Ä—è–º—É—é.
                    </div>
                  </div>
                )}
                <div style={{ fontSize: 12, color: "rgba(255,255,255,0.4)", marginBottom: 12, lineHeight: 1.5 }}>
                  {mob ? "–ú–æ–∂–Ω–æ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–≥—Ä—É–∑–∏—Ç—å:" : "–°—Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—Ä—É–π—Ç–µ –∑–∞—è–≤–∫—É, –∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç, –∏–ª–∏"} <span style={{ color: "#52b788" }}>{mob ? "" : "–≤—Å—Ç–∞–≤—å—Ç–µ –∏–∑ –±—É—Ñ–µ—Ä–∞ (Ctrl+V)"}</span>
                </div>
                {/* Two separate inputs ‚Äî fixes iPhone bug with dynamic capture attribute */}
                <input ref={galleryRef} type="file" accept="image/*" style={{ display: "none" }} onChange={handlePhoto} />
                <input ref={cameraRef} type="file" accept="image/*" capture="environment" style={{ display: "none" }} onChange={handlePhoto} />
                <div style={{ display: "flex", gap: 8, marginBottom: 8 }}>
                  <button onClick={() => galleryRef.current?.click()} style={{
                    flex: 1, padding: "24px 16px", borderRadius: 12, cursor: "pointer",
                    background: "rgba(255,255,255,0.03)", border: "2px dashed rgba(82,183,136,0.3)",
                    display: "flex", flexDirection: "column", alignItems: "center", gap: 6,
                  }}>
                    <span style={{ fontSize: 28 }}>üñº</span>
                    <span style={{ fontSize: 12, fontWeight: 700, color: "#52b788", fontFamily: "'Nunito',sans-serif" }}>–ò–∑ –≥–∞–ª–µ—Ä–µ–∏</span>
                  </button>
                  <button onClick={() => cameraRef.current?.click()} style={{
                    flex: 1, padding: "24px 16px", borderRadius: 12, cursor: "pointer",
                    background: "rgba(255,255,255,0.03)", border: "2px dashed rgba(82,183,136,0.3)",
                    display: "flex", flexDirection: "column", alignItems: "center", gap: 6,
                  }}>
                    <span style={{ fontSize: 28 }}>üì∑</span>
                    <span style={{ fontSize: 12, fontWeight: 700, color: "#52b788", fontFamily: "'Nunito',sans-serif" }}>–ö–∞–º–µ—Ä–∞</span>
                  </button>
                </div>
                {/* Paste zone ‚Äî desktop only */}
                {!mob && (
                  <div style={{
                    padding: "14px", borderRadius: 10, textAlign: "center",
                    background: "rgba(82,183,136,0.05)", border: "1px dashed rgba(82,183,136,0.2)",
                  }}>
                    <span style={{ fontSize: 12, color: "rgba(82,183,136,0.6)" }}>üìã Ctrl+V ‚Äî –≤—Å—Ç–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç –∏–∑ –±—É—Ñ–µ—Ä–∞</span>
                  </div>
                )}
                <div style={{ fontSize: 11, color: "rgba(255,255,255,0.25)", marginTop: 8, lineHeight: 1.5 }}>
                  {mob ? "–°–æ–≤–µ—Ç: –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –≤ —á–∞—Ç —Å Claude, —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç ‚Üí –≤–∫–ª–∞–¥–∫–∞ ¬´–¢–µ–∫—Å—Ç¬ª" : "AI –æ–±—Ä–∞–±–æ—Ç–∫–∞ ~10-20 —Å–µ–∫. –õ—É—á—à–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å —á—ë—Ç–∫–∏–º–∏ —Ñ–æ—Ç–æ —Ç–∞–±–ª–∏—Ü."}
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<MetalCalculator />);
</script>
</body>
</html>
